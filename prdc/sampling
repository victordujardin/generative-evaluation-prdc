import random
from typing import List, Any

def sequential_weighted_sample(
    data: List[Any],
    weights: List[float],
    n: int,
    seed: int = None
) -> List[Any]:
    """
    Perform sequential weighted random sampling without replacement.

    Parameters:
    - data (List[Any]): The list of observations to sample from.
    - weights (List[float]): The list of selection probabilities for each observation.
                             Each probability should be in the range [0, 1].
    - n (int): The number of observations to sample.
    - seed (int, optional): Seed for the random number generator to ensure reproducibility.

    Returns:
    - List[Any]: A list of sampled observations.
    """

    if seed is not None:
        random.seed(seed)

    if len(data) != len(weights):
        raise ValueError("The length of data and weights must be the same.")

    if not 0 < n <= len(data):
        raise ValueError("Sample size 'n' must be between 1 and the number of observations in data.")

    # Pair each observation with its corresponding weight
    paired_data = list(zip(data, weights))

    # Shuffle the paired data to randomize the order
    random.shuffle(paired_data)

    sampled = []
    remaining = []

    # Sequentially evaluate each observation
    for observation, weight in paired_data:
        if len(sampled) >= n:
            break  # Desired sample size achieved

        if not (0 <= weight <= 1):
            raise ValueError("All weights must be between 0 and 1.")

        r = random.random()
        if r <= weight:
            sampled.append(observation)
        else:
            remaining.append(observation)

    # If not enough samples have been selected, randomly select the remaining from unselected observations
    if len(sampled) < n:
        needed = n - len(sampled)
        if len(remaining) < needed:
            raise ValueError("Not enough observations to sample the desired number without replacement.")
        additional_samples = random.sample(remaining, needed)
        sampled.extend(additional_samples)

    return sampled
